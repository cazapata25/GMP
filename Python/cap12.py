# -*- coding: utf-8 -*-
"""cap12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BbYEPnhtPSoeIIAQ9N8M1E2aaZJhQ8Fc

# Gestión Moderna de Portafolio
### Autores Bernardo León y Carlos Zapata
### (C) Copyright 2023

## Capitulo 12: Modelo Black-Litterman
"""

# Commented out IPython magic to ensure Python compatibility.
#Librerías usadas
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %pip install --quiet yfinance
import yfinance as yf
import warnings
warnings.filterwarnings("ignore")

# Información histórica dentro de muetsra (In-sample) para las acciones
fechai = "2015-12-01"
fechaf = "2020-12-31"
periodicidad = "1Mo"
activos = ["ADBE","MCD","MSCI","MSFT","NEE","PG","RSG","WMT"]
precios = yf.download(activos,start=fechai,end=fechaf,interval=periodicidad)['Adj Close'].dropna()
retornos = np.log(precios/precios.shift(1)).dropna()
mu = retornos.mean()*12
cov = retornos.cov()*12
sigma= retornos.std()*np.sqrt(12)
n = len(mu)

indice = ["^GSPC"]
p_indice = yf.download(indice,start=fechai,end=fechaf,interval=periodicidad)['Adj Close'].dropna()
r_indice = np.log(p_indice/p_indice.shift(1)).dropna()
rpm = r_indice.mean()*12
sigmapm = r_indice.std()*np.sqrt(12)

# Estimación de betas 
from scipy import stats
t =len(retornos)
def linestim(x):
  return intercept + slope * x
betas = np.zeros((n,1))

for i in range(n):
  slope, intercept, r, p, se = stats.linregress(r_indice, retornos.iloc[:,i])
  model = list(map(linestim, r_indice))
  betas[i] = slope

betas= pd.DataFrame(betas.T,columns=activos)

# Retornos de equilibrio
rf = 0
pi = betas * (rpm-rf)

datos = pd.concat({'Retornos':pd.DataFrame(mu),'Volatilidades':pd.DataFrame(sigma),'Betas':betas.T, 'Pi' : pi.T},axis=1).T
datos

# Pesos portafolio de equilibrio
delta = (rpm - rf)/sigmapm**2
wpequi = ((np.linalg.inv(delta*cov) @ pi.T)/ np.sum(np.linalg.inv(delta*cov) @ pi.T))
wpequi = pd.DataFrame(wpequi.values.T,columns=activos)
wpequi

# Modelo Black Litterman
tau = 0.025 # Nivel de confiabilidad

# Expectativas: views
q = np.array([[0.035],[0.148],[0.11] ])

P = np.array([[-1, 1, 0, 0, 0, 0, 0, 0],
              [0, 0, 0, 0, 1, 0, 0, 0],
              [0, 0, 1, 0, 0, 0, -1, 0]])

omega = np.array([[P[0,:].T@cov@P[0,:],0,0], [0,P[1,:].T@cov@P[1,:],0], [0,0,P[2,:].T@cov@P[2,:]]  ]) #np.matrix(np.diag(np.diag(P.T @ (tau * cov)  P)))

print('Views: ', q)
print('Matriz Link: ', P)
print('Matriz Omega: ', omega)

def black_litterman(mu, cov, P, q, tau, delta, riskfree):
    P = np.matrix(P)
    PI = np.matrix(pi)
    Q = np.matrix(q)
    S = np.matrix(cov)
    Omega = np.matrix(np.diag(np.diag(P * (tau * S) * P.T))) 
    PI_bl = ((tau * S).I + P.T * Omega.I * P).I * ((tau * S).I * PI.T + P.T * Omega.I * q)
    mu_bl = PI_bl + rf
    return mu_bl.T

mubl = black_litterman(mu, cov, P, q, tau, delta, rf)
print('Retornos: ', mubl)

wbl = (np.linalg.inv(delta*cov) @ mubl.T)/ np.sum(np.linalg.inv(delta*cov) @ mubl.T)
print('Pesos: ', wbl.T)